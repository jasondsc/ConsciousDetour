---
title: "ValueGuidedConstrual"
output: html_document
date: "2024-05-03"
---


```{r read in new mazes and test associations}

library(ggplot2)

maze_meta_data = read.csv('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/experiments/mazes/mazesfinal/Lateralized_mazes_stats.csv')

maze_meta_data= maze_meta_data[-1]
maze_meta_data$lateralized= as.factor(maze_meta_data$lateralized)

# Plot the individuals
jitter_pos=position_jitter(width = .2, height = 0, seed = 1)

ggplot(maze_meta_data, aes(x=lateralized, y=goal_dist, color=lateralized, fill= lateralized))+  theme_classic() + xlab("") + geom_point(shape=21, color="white", size=5, position = jitter_pos, alpha=0.5)  + ylab("distance to goal") + scale_x_discrete(breaks=c("0","1"),
        labels=c("non-lateralized", "lateralized")) + theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14), legend.position = 'none') + scale_fill_manual(values=c('#B9E615', '#F36A17')) + geom_boxplot(width=0.1, colour= 'black', outliers = FALSE) 

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/results/R_plot_goal_distance.pdf', device = "pdf", width= 5, height =5)


ggplot(maze_meta_data, aes(x=lateralized, y=Moves, color=lateralized, fill= lateralized))+  theme_classic() + xlab("") + geom_point(shape=21, color="white", size=5, position = jitter_pos, alpha=0.5)  + ylab("optimal solution (moves)") + scale_x_discrete(breaks=c("0","1"),
        labels=c("non-lateralized", "lateralized")) + theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14), legend.position = 'none') + scale_fill_manual(values=c('#B9E615', '#F36A17')) + geom_boxplot(width=0.1, colour= 'black', outliers = FALSE) 

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/results/R_plot_optimal_moves.pdf', device = "pdf", width= 5, height =5)

ggplot(maze_meta_data, aes(x=lateralized, y=start_dist, color=lateralized, fill= lateralized))+  theme_classic() + xlab("") + geom_point(shape=21, color="white", size=5, position = jitter_pos, alpha=0.5)  + ylab("distance to start") + scale_x_discrete(breaks=c("0","1"),
        labels=c("non-lateralized", "lateralized")) + theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14), legend.position = 'none') + scale_fill_manual(values=c('#B9E615', '#F36A17')) + geom_boxplot(width=0.1, colour= 'black', outliers = FALSE) 

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/results/R_plot_start_distance.pdf', device = "pdf", width= 5, height =5)


ggplot(maze_meta_data, aes(x=lateralized, y=wall_dist, color=lateralized, fill= lateralized))+  theme_classic() + xlab("") + geom_point(shape=21, color="white", size=5, position = jitter_pos, alpha=0.5)  + ylab("distance to wall") + scale_x_discrete(breaks=c("0","1"),
        labels=c("non-lateralized", "lateralized")) + theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14), legend.position = 'none') + scale_fill_manual(values=c('#B9E615', '#F36A17')) + geom_boxplot(width=0.1, colour= 'black', outliers = FALSE) 

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/results/R_plot_wall_distance.pdf', device = "pdf", width= 5, height =5)


ggplot(maze_meta_data, aes(x=lateralized, y=center_dist, color=lateralized, fill= lateralized))+  theme_classic() + xlab("") + geom_point(shape=21, color="white", size=5, position = jitter_pos, alpha=0.5)  + ylab("distance to centre") + scale_x_discrete(breaks=c("0","1"),
        labels=c("non-lateralized", "lateralized")) + theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14), legend.position = 'none') + scale_fill_manual(values=c('#B9E615', '#F36A17')) + geom_boxplot(width=0.1, colour= 'black', outliers = FALSE) 

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/results/R_plot_centre_distance.pdf', device = "pdf", width= 5, height =5)

ggplot(maze_meta_data, aes(x=lateralized, y= log10(dVGC), color=lateralized, fill= lateralized))+  theme_classic() + xlab("") + geom_point(shape=21, color="white", size=5, position = jitter_pos, alpha=0.5)  + ylab("log 10 dynamic VGC") + scale_x_discrete(breaks=c("0","1"),
        labels=c("non-lateralized", "lateralized")) + theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14), legend.position = 'none') + scale_fill_manual(values=c('#B9E615', '#F36A17')) + geom_boxplot(width=0.1, colour= 'black', outliers = FALSE) 

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/results/R_plot_dynamic_VGC.pdf', device = "pdf", width= 5, height =5)

```





```{r test continuous values of lateralization and artifacts}

library(dplyr)

maze_stats= read.csv('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/experiments/mazes/mazesfinal/Lateralized_mazes_stats.csv', na.strings = 'NaN')
maze_stats=maze_stats[order(maze_stats$grid),]

temp=maze_stats %>% group_by(grid, side) %>% summarise(sumdVGC= sum(dVGC), sumsVGC= sum(sVGC))

latmazes= data.frame(grid = unique(temp$grid),
  lat_dVGC =abs((temp$sumdVGC[temp$side=='R'] - temp$sumdVGC[temp$side=='L']) / (temp$sumdVGC[temp$side=='R'] + temp$sumdVGC[temp$side=='L'])),
  lat_sVGC= abs((temp$sumsVGC[temp$side=='R'] - temp$sumsVGC[temp$side=='L']) / (temp$sumsVGC[temp$side=='R'] + temp$sumsVGC[temp$side=='L'])))

latmazesRL=latmazes

maze_stats= maze_stats[!is.na(maze_stats$Quad),]

temp=maze_stats %>% group_by(grid, Quad) %>% summarise(sumdVGC= sum(dVGC), sumsVGC= sum(sVGC))

latmazes= data.frame(grid = unique(temp$grid),
  hlat_dVGC =abs((temp$sumdVGC[temp$Quad=='U'] - temp$sumdVGC[temp$Quad=='L']) / (temp$sumdVGC[temp$Quad=='U'] + temp$sumdVGC[temp$Quad=='L'])),
  hlat_sVGC= abs((temp$sumsVGC[temp$Quad=='U'] - temp$sumsVGC[temp$Quad=='L']) / (temp$sumsVGC[temp$Quad=='U'] + temp$sumsVGC[temp$Quad=='L'])))

dictionary_of_maze=unique(paste(maze_stats$lateralized, as.numeric(substr(maze_stats$grid, 7,8))))

# make sure the two model predictions are related!
cor.test(latmazes$hlat_dVGC, latmazes$hlat_sVGC)

temp=maze_meta_data %>% group_by(grid) %>% summarise(avgsVGC= mean(sVGC), avgdVGC= mean(dVGC), avggoaldist= mean(goal_dist), avgstartdist= mean(start_dist), avgwalldist= mean(wall_dist), avgcenterdist= mean(center_dist))

cor.test(temp$avggoaldist, latmazes$hlat_sVGC, method = 'spearman')
cor.test(temp$avgstartdist, latmazes$hlat_sVGC, method = 'spearman')
cor.test(temp$avgwalldist, latmazes$hlat_sVGC, method = 'spearman')
cor.test(temp$avgcenterdist, latmazes$hlat_sVGC, method = 'spearman')

cor.test(temp$avggoaldist, latmazesRL$lat_sVGC, method = 'spearman')
cor.test(temp$avgstartdist, latmazesRL$lat_sVGC, method = 'spearman')
cor.test(temp$avgwalldist, latmazesRL$lat_sVGC, method = 'spearman')
cor.test(temp$avgcenterdist, latmazesRL$lat_sVGC, method = 'spearman')

temp$lat_sVGC= latmazesRL$lat_sVGC
temp$lat_dVGC= latmazesRL$lat_dVGC
temp$hlat_sVGC= latmazes$hlat_sVGC
temp$hlat_dVGC= latmazes$hlat_dVGC
temp$Lateral= rep(c('lateralized', 'non-lateralized'),12)

# maze sets do not differ in terms of vertical lateralization
RVAideMemoire::perm.t.test(temp$hlat_dVGC[temp$Lateral=='lateralized'],temp$hlat_dVGC[temp$Lateral=='non-lateralized'], nperm=1000)

RVAideMemoire::perm.t.test(temp$hlat_sVGC[temp$Lateral=='lateralized'],temp$hlat_sVGC[temp$Lateral=='non-lateralized'], nperm=1000)

ggplot(temp, aes(lat_sVGC, group= Lateral, color= Lateral, fill=Lateral, alpha=0.5)) +geom_histogram(aes( color= Lateral, fill=Lateral, group= Lateral), alpha= 0.5, bins = 9, position = 'identity') +
  theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14), legend.position = 'none') +
  labs(x = "awareness of obstacle", y = "count")  + ggpubr::theme_classic2() +
  ggtitle("") + scale_fill_manual(values=c('#F36A17', '#B9E615')) + scale_color_manual(values=c('#F36A17', '#B9E615')) 

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/datapilot/hist_of_lateralization_LR.pdf', device = "pdf", width= 6, height =5)

ggplot(temp, aes(hlat_sVGC, group= Lateral, color= Lateral, fill=Lateral, alpha=0.5)) +geom_histogram(aes( color= Lateral, fill=Lateral, group= Lateral), alpha= 0.5, bins = 9, position = 'identity') +
  theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14), legend.position = 'none') +
  labs(x = "awareness of obstacle", y = "count")  + ggpubr::theme_classic2() +
  ggtitle("") + scale_fill_manual(values=c('#B9E615', '#F36A17')) + scale_color_manual(values=c('#B9E615', '#F36A17')) 

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/datapilot/hist_of_lateralization_UL.pdf', device = "pdf", width= 6, height =5)


# do nuissance covariates differ across maze sets
maze_meta_data$log10dVGC= maze_meta_data$dVGC

BayesFactor::generalTestBF(log10dVGC ~ goal_dist*lateralized,  data=maze_meta_data, whichModels = "top")
# weak evidence for relationship but no evidence for interaction!!!
# below 1/10 strong in favour of effect

BayesFactor::generalTestBF(log10dVGC ~ start_dist*lateralized,  data=maze_meta_data, whichModels = "top")

BayesFactor::generalTestBF(log10dVGC ~ wall_dist*lateralized,  data=maze_meta_data, whichModels = "top")

BayesFactor::generalTestBF(log10dVGC ~ center_dist*lateralized,  data=maze_meta_data, whichModels = "top")

# all models return ambiguous evidence!!!! 


ggplot(maze_meta_data, aes(x=goal_dist, y= log10(dVGC), color=lateralized, fill= lateralized))+  theme_classic() + xlab("") + geom_point(shape=21, color="white", size=5, position = jitter_pos, alpha=0.5)  + ylab("log 10 dynamic VGC") + xlab('distance to goal')  + theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14), legend.position = 'none') + scale_fill_manual(values=c('#B9E615', '#F36A17')) +
  stat_smooth(aes(color=lateralized, fill= lateralized), linetype = 'dashed', method = "glm",formula = y ~ poly(x, 1),fullrange = T) + scale_color_manual(values=c('#B9E615', '#F36A17'))

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/results/R_plot_goal_distance_dynamic_VGC.pdf', device = "pdf", width= 5, height =5)

ggplot(maze_meta_data, aes(x=start_dist, y= log10(dVGC), color=lateralized, fill= lateralized))+  theme_classic() + xlab("") + geom_point(shape=21, color="white", size=5, position = jitter_pos, alpha=0.5)  + ylab("log 10 dynamic VGC") + xlab('distance to start')  + theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14), legend.position = 'none') + scale_fill_manual(values=c('#B9E615', '#F36A17')) +
  stat_smooth(aes(color=lateralized, fill= lateralized), linetype = 'dashed', method = "glm",formula = y ~ poly(x, 1),fullrange = T) + scale_color_manual(values=c('#B9E615', '#F36A17'))

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/results/R_plot_start_distance_dynamic_VGC.pdf', device = "pdf", width= 5, height =5)


ggplot(maze_meta_data, aes(x=wall_dist, y= log10(dVGC), color=lateralized, fill= lateralized))+  theme_classic() + xlab("") + geom_point(shape=21, color="white", size=5, position = jitter_pos, alpha=0.5)  + ylab("log 10 dynamic VGC") + xlab('distance to walls')  + theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14), legend.position = 'none') + scale_fill_manual(values=c('#B9E615', '#F36A17')) +
  stat_smooth(aes(color=lateralized, fill= lateralized), linetype = 'dashed', method = "glm",formula = y ~ poly(x, 1),fullrange = T) + scale_color_manual(values=c('#B9E615', '#F36A17'))

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/results/R_plot_wall_distance_dynamic_VGC.pdf', device = "pdf", width= 5, height =5)


ggplot(maze_meta_data, aes(x=center_dist, y= log10(dVGC), color=lateralized, fill= lateralized))+  theme_classic() + xlab("") + geom_point(shape=21, color="white", size=5, position = jitter_pos, alpha=0.5)  + ylab("log 10 dynamic VGC") + xlab('distance to centre')  + theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14), legend.position = 'none') + scale_fill_manual(values=c('#B9E615', '#F36A17')) +
  stat_smooth(aes(color=lateralized, fill= lateralized), linetype = 'dashed', method = "glm",formula = y ~ poly(x, 1),fullrange = T) + scale_color_manual(values=c('#B9E615', '#F36A17'))

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/results/R_plot_centre_distance_dynamic_VGC.pdf', device = "pdf", width= 5, height =5)


```



```{r Calculate Hamming distance}

json_data <- rjson::fromJSON(file='~/Documents/ValueBasedConstrualTask/value-guided-construal-main/experiments/mazes/mazesfinal/mazes_Lateralized.json')

json_data2 <- rjson::fromJSON(file='~/Documents/ValueBasedConstrualTask/value-guided-construal-main/experiments/mazes/mazesfinal/mazes_Nonlateralized.json')

json_data <-append(json_data, json_data2)
# function that takes in json inputs and converts to matrix for simple math
json2matrix <- function(mazeA){
  m=t(matrix(unlist(strsplit(mazeA, split='')), nrow = 11))
  return(m)
}

# compute hamming distance between mazes to see how similar they are perceptually 
hamming_distance <- function(mazeA, mazeB){
  m=dim(mazeA)[1]
  n=dim(mazeA)[2]
  
  if(dim(mazeA)[1] != dim(mazeB)[1] || dim(mazeA)[2] != dim(mazeB)[2]) {
    stop("inputs not the same size")
  }
  # binarize matrix
  mazeA[mazeA!='.']=1
  mazeB[mazeB!='.']=1
  
  mazeA[mazeA=='.']=0
  mazeB[mazeB=='.']=0
  
  # get diff
  diffmaze= matrix(as.numeric(mazeA), nrow = 11)- matrix(as.numeric(mazeB), nrow = 11)
  hamming_dist= sum(abs(diffmaze))

  return(hamming_dist)
}



# compute hamming distance between mazes to see how similar they are perceptually 
obstacle_distances <- function(mazeA){
  number_obs= length(unique(as.numeric(mazeA)))-1
  max_obs= max(as.numeric(mazeA), na.rm = TRUE)
  min_obs= min(as.numeric(mazeA), na.rm = TRUE)
  mazeA[mazeA=='G']=NaN
  mazeA[mazeA=='S']=NaN
  mazeA[mazeA=='.']=NaN
  mazeA[mazeA=='#']=NaN

  obstacle_distances_output= matrix(, nrow=number_obs*number_obs, 3)
  obstacle_distances_output[,1] = rep(seq(min_obs,max_obs), each=6)
  obstacle_distances_output[,2] = rep(seq(min_obs,max_obs), 6)
  
  output=c()
  for (i in min_obs:max_obs){
    for (j in min_obs:max_obs){
      obs1=which(mazeA== as.character(i))
      obs1x= obs1 %% 11
      obs1x[obs1x==0] =11
      obs1y= ceiling(obs1/11)
      obs2= which(mazeA== as.character(j))
      obs2x= obs2 %% 11
      obs2x[obs2x==0] =11
      obs2y= ceiling(obs2/11)
      
      distance =c()
      for (ob in length(obs1x)){
      distance= c(distance, abs(obs1x[ob]-obs2x) + abs(obs1y[ob]-obs2y))
      }
      for (ob in length(obs2x)){
      distance= c(distance, abs(obs2x[ob]-obs1x) + abs(obs2y[ob]-obs1y))
      }
    
      output= c(output,min(distance))
    }
  }
  obstacle_distances_output[,3]=output
  return(obstacle_distances_output)
}

matrix_mazes=lapply(json_data, json2matrix)

hamming_dist_mazes= matrix(, nrow=length(json_data)*length(json_data), 3)
count=1
for (i in 1:length(json_data)){
  for (j in 1:length(json_data)){
    hamming_dist_mazes[count,1]= i
    hamming_dist_mazes[count,2]= j
    hamming_dist_mazes[count,3]= hamming_distance(matrix_mazes[[i]], matrix_mazes[[j]])
    count=count+1
  }
}

hamming_dist_mazes= as.data.frame(hamming_dist_mazes)
colnames(hamming_dist_mazes)= c('x', 'y', 'hamming_dist')
library(ggplot2)

ggplot(hamming_dist_mazes, aes(x, y, fill= hamming_dist)) + 
  geom_tile() + scale_y_reverse()+  theme_void() + colorspace::scale_fill_continuous_sequential(palette= 'Lajolla', rev= FALSE, limits= c(0, 50)) + geom_hline(aes(yintercept = 12.5), colour = 'white') + geom_vline(aes(xintercept = 12.5), colour = 'white') + 
  theme(legend.key.height = unit(1, "cm"),
        legend.title = element_text(size = 12, angle = 270),
        legend.title.align = 0.5,
        legend.direction = "vertical", legend.text.position = 'right',
        legend.title.position = 'right') + annotate("text", x = 7, y=-0.75, label = "lateralized") + annotate("text", x = 7+12, y=-0.75, label = "non-lateralized") + annotate("text", x = -0.75, y=7+12, label = "non-lateralized", angle = 90) + annotate("text", x = -0.75, y=7, label = "lateralized", angle = 90)

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/results/R_plot_Hamming_distance_between_mazes.pdf', device = "pdf", width= 6, height =5)


```



```{r Calculate averaging}

library(lme4)

json_data <- rjson::fromJSON(file='~/Documents/ValueBasedConstrualTask/value-guided-construal-main/experiments/mazes/mazesfinal/mazes_Lateralized.json')

json_data2 <- rjson::fromJSON(file='~/Documents/ValueBasedConstrualTask/value-guided-construal-main/experiments/mazes/mazesfinal//mazes_Nonlateralized.json')

maze_stats= read.csv('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/new_mazes_stats.csv', na.strings = 'NaN')

json_data <-append(json_data, json_data2)
# function that takes in json inputs and converts to matrix for simple math
json2matrix <- function(mazeA){
  m=t(matrix(unlist(strsplit(mazeA, split='')), nrow = 11))
  return(m)
}

# function to compute manhattan distance between all pairs of obstacles 
obstacle_distances <- function(mazeA){
  number_obs= length(unique(as.numeric(mazeA)))-1
  max_obs= max(as.numeric(mazeA), na.rm = TRUE)
  min_obs= min(as.numeric(mazeA), na.rm = TRUE)
  mazeA[mazeA=='G']=NaN
  mazeA[mazeA=='S']=NaN
  mazeA[mazeA=='.']=NaN
  mazeA[mazeA=='#']=NaN

  obstacle_distances_output= matrix(, nrow=number_obs*number_obs, 3)
  obstacle_distances_output[,1] = rep(seq(min_obs,max_obs), each=6)
  obstacle_distances_output[,2] = rep(seq(min_obs,max_obs), 6)
  
  output=c()
  for (i in min_obs:max_obs){
    for (j in min_obs:max_obs){
      obs1=which(mazeA== as.character(i))
      obs1x= obs1 %% 11
      obs1x[obs1x==0] =11
      obs1y= ceiling(obs1/11)
      obs2= which(mazeA== as.character(j))
      obs2x= obs2 %% 11
      obs2x[obs2x==0] =11
      obs2y= ceiling(obs2/11)
      
      distance =c()
      for (obsA in 1:length(obs1x)){
        for (obsB in 1:length(obs2x)){
          distance= c(distance, abs(obs1x[obsA]-obs2x) + abs(obs1y[obsB]-obs2y))
        }
      }
    
      output= c(output,min(distance))
    }
  }
  obstacle_distances_output[,3]=output
  return(obstacle_distances_output)
}

matrix_mazes=lapply(json_data, json2matrix)

# compute distances between obstacles and adjust model prediction

update_maze_states <- function(k_min, maze_stats_new){
count=1
for (i in 1:length(json_data)){

    grid_name_temp= names(matrix_mazes)[i]
    temp= obstacle_distances(matrix_mazes[[i]])
    sVGC = maze_stats_new$sVGC[maze_stats_new$grid == grid_name_temp]
    sVGC_new = maze_stats_new$sVGC[maze_stats_new$grid == grid_name_temp]
    
    dVGC = maze_stats_new$dVGC[maze_stats_new$grid == grid_name_temp]
    dVGC_new = maze_stats_new$dVGC[maze_stats_new$grid == grid_name_temp]
    
    count=1
    for(j in unique(temp[,1])){
      obs_temp=temp[temp[,1]==j,]
      index= obs_temp[,3] <= k_min
      sVGC_new[count] = mean(sVGC[index])
      dVGC_new[count] = mean(dVGC[index])
      count= count+1
    }
    maze_stats_new$new_sVGC[maze_stats_new$grid == grid_name_temp]=sVGC_new
    maze_stats_new$new_dVGC[maze_stats_new$grid == grid_name_temp]=dVGC_new
}
return(maze_stats_new)
}

library(dplyr)
library(ggplot2)
data= read.csv('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/datapilot/allDataConcatnated.csv', na.strings = 'NaN')
data$Aware.ReportObs.scaled= plyr::mapvalues(data$Aware.ReportObs, c(1,2,3,4,5,6,7,8,9), c(0,0.125,0.25,0.375,0.5,0.625,0.75,0.875,1))

data$Lateralized.factor= factor(plyr::mapvalues(data$Lateralized, c(0,1), c('non-lateralized', 'lateralized')), levels = c('non-lateralized', 'lateralized'))


# apply new model predictions to data

AIC_sVGC= c()
BIC_sVGC= c()
AIC_dVGC= c()
BIC_dVGC= c()

# loop over possible k here and apply model to data 

for (k in c(1,2,3,4,5,6,7,8,9,10)){
  rm(maze_stats_new)
  maze_stats_new=maze_stats
  maze_stats_new=update_maze_states(k, maze_stats_new)
  maze_stats_new=rbind(maze_stats_new,maze_stats_new)
  
  maze_stats_new$MazeID= c(rep(unlist(lapply(c(1:12), rep,6)),2), rep(unlist(lapply(c(13:24), rep,6)),2))
  maze_stats_new$Obs.No= as.integer(substr(maze_stats_new$obstacle, 5, 5))
  maze_stats_new$Obs.No= maze_stats_new$Obs.No+1 # bc of python index
  
  dictionary_of_maze= paste(maze_stats_new$lateralized, maze_stats_new$MazeID, maze_stats_new$Obs.No)
  
  index_mazes=paste(data$Lateralized, data$MazeID, data$Obs.No)
  data$new_sVGC=plyr::mapvalues(index_mazes, dictionary_of_maze, maze_stats_new$new_sVGC)
  data$new_dVGC=plyr::mapvalues(index_mazes, dictionary_of_maze, maze_stats_new$new_dVGC)
  
  data$new_sVGC= as.numeric(data$new_sVGC)
  data$new_dVGC= as.numeric(data$new_dVGC)
  
  data$sVGC.Obs.zscore= scale(data$sVGC.Obs)[,1]
  data$dVGC.Obs.zscore= scale(data$dVGC.Obs)[,1]
  data$new_sVGC.zscore= scale(data$new_sVGC)[,1]
  data$new_dVGC.zscore= scale(data$new_dVGC)[,1]
  
  lm2= lmer(Aware.ReportObs.scaled ~  (1 | MazeID) + (1 | Subject.Code) + new_sVGC.zscore, data= data)
  AIC_sVGC= c(AIC_sVGC,AIC(lm2))
  BIC_sVGC= c(BIC_sVGC,BIC(lm2))
  
  lm2= lmer(Aware.ReportObs.scaled ~  (1 | MazeID) + (1 | Subject.Code) + new_dVGC.zscore, data= data)
  
  AIC_dVGC= c(AIC_dVGC,AIC(lm2))
  BIC_dVGC= c(BIC_dVGC,BIC(lm2))

}

lm2= lmer(Aware.ReportObs.scaled ~  (1 | MazeID) + (1 | Subject.Code) + sVGC.Obs.zscore, data= data)
AIC(lm2)
BIC(lm2)

library(ggplot2)

data4plot = data.frame(AIC=AIC_sVGC, BIC= BIC_sVGC, k= 1:10)
ggplot(data4plot, aes(x=k, y= BIC)) + geom_point(size=4, color= '#F36A17') + geom_path(color= '#F36A17',size=1.25)   + ggpubr::theme_classic2() +  geom_hline(yintercept = BIC(lm2), linetype= 'dashed', color= '#899499', size=1.25) + ylab('BIC') + xlab('proximity parameter') + scale_y_continuous(trans = "reverse")

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/results/R_plot_BIC_of_new_model_pilot_data_proximity_sVGC.pdf', device = "pdf", width= 6, height =5)


lm2= lmer(Aware.ReportObs.scaled ~  (1 | MazeID) + (1 | Subject.Code) + dVGC.Obs.zscore, data= data)
AIC(lm2)
BIC(lm2)

data4plot = data.frame(AIC=AIC_dVGC, BIC= BIC_dVGC, k= 1:10)
ggplot(data4plot, aes(x=k, y= BIC)) + geom_point(size=4, color= '#F36A17') + geom_path(color= '#F36A17',size=1.25)   + ggpubr::theme_classic2() +  geom_hline(yintercept = BIC(lm2), linetype= 'dashed', color= '#899499', size=1.25) + ylab('BIC') + xlab('proximity parameter') + scale_y_continuous(trans = "reverse")

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/results/R_plot_BIC_of_new_model_pilot_data_proximity_dVGC.pdf', device = "pdf", width= 6, height =5)


```





```{r check lateralization of original experiment 1}

# original experiment with awareness probes 

library(dplyr)
library(lme4)
library(ggplot2)

data = read.csv('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/experiment_1_data.csv')

temp=data %>% group_by(grid,obstacle) %>% summarise(goal_dist= mean(goal_dist), start_dist= mean(start_dist), wall_dist= mean(walls_dist), center_dist= mean(center_dist), dVGC= mean(dynamic_vgc_weight), sVGC= mean(static_vgc_weight))

maze_stats= read.csv('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/original_stimuli_stats.csv', na.strings = 'NaN')

maze_stats=maze_stats[order(maze_stats$grid),]

dictionary_of_maze=unique(unlist(strsplit(maze_stats$grid, '-0')))[2:17]
dictionary_of_maze[1] = 'grid-0'

maze_stats=maze_stats[!is.na(maze_stats$side),]
temp=maze_stats %>% group_by(grid, side) %>% summarise(sumdVGC= sum(dVGC), sumsVGC= sum(sVGC))

latmazesLR= data.frame(grid = unique(temp$grid),
  lat_dVGC =abs((temp$sumdVGC[temp$side=='R'] - temp$sumdVGC[temp$side=='L']) / (temp$sumdVGC[temp$side=='R'] + temp$sumdVGC[temp$side=='L'])),
  lat_sVGC= abs((temp$sumsVGC[temp$side=='R'] - temp$sumsVGC[temp$side=='L']) / (temp$sumsVGC[temp$side=='R'] + temp$sumsVGC[temp$side=='L'])))


maze_stats=maze_stats[!is.na(maze_stats$quad),]
temp=maze_stats %>% group_by(grid, quad) %>% summarise(sumdVGC= sum(dVGC), sumsVGC= sum(sVGC))

latmazes= data.frame(grid = unique(temp$grid),
  hlat_dVGC =abs((temp$sumdVGC[temp$quad=='U'] - temp$sumdVGC[temp$quad=='L']) / (temp$sumdVGC[temp$quad=='U'] + temp$sumdVGC[temp$quad=='L'])),
  hlat_sVGC= abs((temp$sumsVGC[temp$quad=='U'] - temp$sumsVGC[temp$quad=='L']) / (temp$sumsVGC[temp$quad=='U'] + temp$sumsVGC[temp$quad=='L'])))

# make sure the two model predictions are related!
cor.test(latmazesLR$lat_dVGC, latmazesLR$lat_sVGC)
cor.test(latmazes$hlat_dVGC, latmazes$hlat_sVGC)

cor.test(latmazesLR$lat_sVGC, latmazes$hlat_sVGC)
cor.test(latmazesLR$lat_dVGC, latmazes$hlat_dVGC)

index_mazes=paste(data$grid, data$obstacle)

data$lateralized_values_dVGC=as.numeric(plyr::mapvalues(data$grid, dictionary_of_maze, latmazesLR$lat_dVGC))
data$lateralized_values_sVGC=as.numeric(plyr::mapvalues(data$grid, dictionary_of_maze, latmazesLR$lat_sVGC))

data$hor_values_dVGC=as.numeric(plyr::mapvalues(data$grid, dictionary_of_maze, latmazes$hlat_dVGC))
data$hor_values_sVGC=as.numeric(plyr::mapvalues(data$grid, dictionary_of_maze, latmazes$hlat_sVGC))


data$lat_dVGC_scaled= scale(data$lateralized_values_dVGC)[,1]
data$lat_sVGC_scaled= scale(data$lateralized_values_sVGC)[,1]

data$hor_dVGC_scaled= scale(data$hor_values_dVGC)[,1]
data$hor_sVGC_scaled= scale(data$hor_values_sVGC)[,1]

# need to add subject intercept!!
lm0= lmer(attention_N ~  (1 | grid)+ (1 | sessionId), data= data)
lm1= lmer(attention_N ~  (1 | grid) + (1 | sessionId)+ static_vgc_weight_Z, data= data)
lm2= lmer(attention_N ~  (1 | grid) + (1 | sessionId)+ static_vgc_weight_Z + lat_sVGC_scaled, data= data)
lm3= lmer(attention_N ~  (1 | grid) + (1 | sessionId)+ static_vgc_weight_Z * lat_sVGC_scaled, data= data)
anova(lm0,lm1, lm2, lm3)

sjPlot::tab_model(lm3)
# we see a smaller (but still significant effect!)

# need to add subject intercept!!
lm0= lmer(attention_N ~  (1 | grid)+ (1 | sessionId), data= data)
lm1= lmer(attention_N ~  (1 | grid) + (1 | sessionId)+ static_vgc_weight_Z, data= data)
lm2= lmer(attention_N ~  (1 | grid) + (1 | sessionId)+ static_vgc_weight_Z + lat_sVGC_scaled, data= data)
lm3= lmer(attention_N ~  (1 | grid) + (1 | sessionId)+ static_vgc_weight_Z * hor_sVGC_scaled, data= data)
anova(lm0,lm1, lm2, lm3)

sjPlot::tab_model(lm3)

# need to add subject intercept!!
lm0= lmer(attention_N ~  (1 | grid) + (1 | sessionId), data= data)
lm1= lmer(attention_N ~  (1 | grid) + (1 | sessionId)+ dynamic_vgc_weight_Z, data= data)
lm2= lmer(attention_N ~  (1 | grid) + (1 | sessionId)+ dynamic_vgc_weight_Z + lat_dVGC_scaled, data= data)
lm3= lmer(attention_N ~  (1 | grid) + (1 | sessionId)+ dynamic_vgc_weight_Z * lat_dVGC_scaled, data= data)
anova(lm0,lm1, lm2, lm3)

sjPlot::tab_model(lm3)

lm0= lmer(attention_N ~  (1 | grid) + (1 | sessionId), data= data)
lm1= lmer(attention_N ~  (1 | grid) + (1 | sessionId)+ dynamic_vgc_weight_Z, data= data)
lm2= lmer(attention_N ~  (1 | grid) + (1 | sessionId)+ dynamic_vgc_weight_Z + hor_dVGC_scaled, data= data)
lm3= lmer(attention_N ~  (1 | grid) + (1 | sessionId)+ dynamic_vgc_weight_Z * hor_dVGC_scaled, data= data)
anova(lm0,lm1, lm2, lm3)

sjPlot::tab_model(lm3)


# add in nuissance covariates 
# need to add subject intercept!!
lm0= lmer(attention_N ~  start_dist_Z+ goal_dist_Z + walls_dist_Z + center_dist + (1 | grid) + (1 | sessionId), data= data)
lm1= lmer(attention_N ~ start_dist_Z+ goal_dist_Z + walls_dist_Z + center_dist + (1 | grid) + (1 | sessionId) + static_vgc_weight_Z, data= data)
lm2= lmer(attention_N ~  start_dist_Z+ goal_dist_Z + walls_dist_Z + center_dist +(1 | grid) + (1 | sessionId) + static_vgc_weight_Z + lat_sVGC_scaled, data= data)
lm3= lmer(attention_N ~  start_dist_Z+ goal_dist_Z + walls_dist_Z + center_dist +(1 | grid) + (1 | sessionId) + static_vgc_weight_Z * lat_sVGC_scaled, data= data)
anova(lm0,lm1, lm2, lm3)

sjPlot::tab_model(lm3)
# we see a smaller (but still significant effect!)

lm0= lmer(attention_N ~  start_dist_Z+ goal_dist_Z + walls_dist_Z + center_dist + (1 | grid) + (1 | sessionId), data= data)
lm1= lmer(attention_N ~ start_dist_Z+ goal_dist_Z + walls_dist_Z + center_dist + (1 | grid) + (1 | sessionId) + dynamic_vgc_weight_Z, data= data)
lm2= lmer(attention_N ~  start_dist_Z+ goal_dist_Z + walls_dist_Z + center_dist +(1 | grid) + (1 | sessionId) + dynamic_vgc_weight_Z + lat_dVGC_scaled, data= data)
lm3= lmer(attention_N ~  start_dist_Z+ goal_dist_Z + walls_dist_Z + center_dist +(1 | grid) + (1 | sessionId) + dynamic_vgc_weight_Z * lat_dVGC_scaled, data= data)
anova(lm0,lm1, lm2, lm3)

sjPlot::tab_model(lm3)
# no effect! 


# plot sVGC effect 
data_plot= data

# summarize by maze 
data_plot= data %>% group_by(grid, obstacle) %>% summarise(mean_awareness= mean(attention), mean_sVGC= mean(static_vgc_weight), mean_dVGC= mean(dynamic_vgc_weight),lat_sVGC= mean(lateralized_values_sVGC), lat_dVGC= mean(lateralized_values_dVGC),hor_sVGC= mean(hor_values_sVGC), hor_dVGC= mean(hor_values_dVGC) )

# remove intercept of each maze 
temp=data_plot %>% group_by(grid) %>% summarise(mean_awareness= mean(mean_awareness), mean_sVGC= mean(mean_sVGC), mean_dVGC= mean(mean_dVGC))

data_plot$mean_awareness= data_plot$mean_awareness-  rep(temp$mean_awareness, each=7)
data_plot$mean_sVGC= data_plot$mean_sVGC-  rep(temp$mean_sVGC, each=7)
data_plot$mean_dVGC= data_plot$mean_dVGC-  rep(temp$mean_dVGC, each=7)

ggplot(data_plot, aes(x=mean_sVGC, y= mean_awareness, color=lat_sVGC, fill= lat_sVGC, group = factor(lat_sVGC)))+  geom_point() + theme_classic() + xlab("") +  ylab("awareness reports (scaled)") + xlab('sVGC (scaled)')  + theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14)) + geom_smooth(aes( color=lat_sVGC, fill= lat_sVGC), method='lm', se= FALSE, fullrange = T) +  colorspace::scale_color_continuous_sequential(palette = 'Orange', limits = c(0,1)) + colorspace::scale_fill_continuous_sequential(palette = 'Orange',limits = c(0,1)) 

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/datapilot/ORIGINAL_experiment1_interaction_plot_continuous_lateralized_sVGC.pdf', device = "pdf", width= 6, height =5)

ggplot(data_plot, aes(x=mean_dVGC, y= mean_awareness, color=lat_dVGC, fill= lat_dVGC, group = factor(lat_dVGC)))+  geom_point() + theme_classic() + xlab("") +  ylab("awareness reports (scaled)") + xlab('dVGC (scaled)')  + theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14)) + geom_smooth(aes( color=lat_sVGC, fill= lat_sVGC), method='lm', se= FALSE, fullrange = T) +  colorspace::scale_color_continuous_sequential(palette = 'Orange', limits = c(0,1)) + colorspace::scale_fill_continuous_sequential(palette = 'Orange',limits = c(0,1)) 

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/datapilot/ORIGINAL_experiment1_interaction_plot_continuous_lateralized_dVGC.pdf', device = "pdf", width= 6, height =5)


ggplot(data_plot, aes(x=mean_sVGC, y= mean_awareness, color=hor_sVGC, fill= hor_sVGC, group = factor(hor_sVGC)))+  geom_point() + theme_classic() + xlab("") +  ylab("awareness reports (scaled)") + xlab('sVGC (scaled)')  + theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14)) + geom_smooth(aes( color=lat_sVGC, fill= lat_sVGC), method='lm', se= FALSE, fullrange = T) +  colorspace::scale_color_continuous_sequential(palette = 'Orange', limits = c(0,1)) + colorspace::scale_fill_continuous_sequential(palette = 'Orange',limits = c(0,1)) 

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/datapilot/ORIGINAL_experiment1_interaction_plot_continuous_lateralized_horizontal_sVGC.pdf', device = "pdf", width= 6, height =5)

ggplot(data_plot, aes(x=mean_dVGC, y= mean_awareness, color=hor_dVGC, fill= hor_dVGC, group = factor(hor_dVGC)))+  geom_point() + theme_classic() + xlab("") +  ylab("awareness reports (scaled)") + xlab('dVGC (scaled)')  + theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14)) + geom_smooth(aes( color=lat_sVGC, fill= lat_sVGC), method='lm', se= FALSE, fullrange = T) +  colorspace::scale_color_continuous_sequential(palette = 'Orange', limits = c(0,1)) + colorspace::scale_fill_continuous_sequential(palette = 'Orange',limits = c(0,1)) 

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/datapilot/ORIGINAL_experiment1_interaction_plot_continuous_lateralized_horizontal_dVGC.pdf', device = "pdf", width= 6, height =5)

data$Lateralized.factor = data$lateralized_values_sVGC >=0.5
data$Lateralized.factor= factor(plyr::mapvalues(data$Lateralized.factor, c(1,0), c('lateralized', 'non-lateralized')), levels = c('non-lateralized', 'lateralized'))
data$binarysVGC= data$static_vgc_weight > 0.5
data$binarysVGC= plyr::mapvalues(data$binarysVGC, c(1,0), c('relevant', 'irrelevant'))

ggplot(data, aes(attention_N, group= binarysVGC, color= binarysVGC, fill=binarysVGC, alpha=0.5)) +
  geom_histogram(aes( color= binarysVGC, fill=binarysVGC, group= binarysVGC), alpha= 0.5, bins = 9, position = 'identity') +
  theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14), legend.position = 'none') +
  labs(x = "awareness of obstacle", y = "count")  + ggpubr::theme_classic2() +
  ggtitle("") + scale_fill_manual(values=c('#B9E615', '#F36A17')) + scale_color_manual(values=c('#B9E615', '#F36A17')) + facet_wrap(~Lateralized.factor, nrow = 1, scales = "free")

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/datapilot/ORIG_EXP_1_hist_of_awareness_by_maze_type2.pdf', device = "pdf", width= 10, height =5)


ggplot(data, aes(attention_N, group= binarysVGC, color= binarysVGC, fill=binarysVGC, alpha=0.5)) +
  geom_density(aes( color= binarysVGC, fill=binarysVGC, group= binarysVGC), alpha= 0.5, bins = 9, position = 'identity') +
  theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14), legend.position = 'none') +
  labs(x = "awareness of obstacle", y = "count")  + ggpubr::theme_classic2() +
  ggtitle("") + scale_fill_manual(values=c('#B9E615', '#F36A17')) + scale_color_manual(values=c('#B9E615', '#F36A17')) + facet_wrap(~Lateralized.factor, nrow = 1)

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/datapilot/ORIG_EXP_1_hist_of_awareness_by_maze_type2.pdf', device = "pdf", width= 10, height =5)

```



```{r check lateralization of original experiment 2}

#expriment with awareness probes, but obstacles disapear after participants starts to move

library(dplyr)
library(ggplot2)

data = read.csv('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/experiment_2_data.csv')

temp=data %>% group_by(grid,obstacle) %>% summarise(goal_dist= mean(goal_dist), start_dist= mean(start_dist), wall_dist= mean(walls_dist), center_dist= mean(center_dist), dVGC= mean(dynamic_vgc_weight), sVGC= mean(static_vgc_weight))

maze_stats= read.csv('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/original_stimuli_stats.csv', na.strings = 'NaN')

maze_stats=maze_stats[order(maze_stats$grid),]

dictionary_of_maze=unique(unlist(strsplit(maze_stats$grid, '-0')))[2:17]
dictionary_of_maze[1] = 'grid-0'

maze_stats=maze_stats[!is.na(maze_stats$side),]
temp=maze_stats %>% group_by(grid, side) %>% summarise(sumdVGC= sum(dVGC), sumsVGC= sum(sVGC))

latmazesLR= data.frame(grid = unique(temp$grid),
  lat_dVGC =abs((temp$sumdVGC[temp$side=='R'] - temp$sumdVGC[temp$side=='L']) / (temp$sumdVGC[temp$side=='R'] + temp$sumdVGC[temp$side=='L'])),
  lat_sVGC= abs((temp$sumsVGC[temp$side=='R'] - temp$sumsVGC[temp$side=='L']) / (temp$sumsVGC[temp$side=='R'] + temp$sumsVGC[temp$side=='L'])))


maze_stats=maze_stats[!is.na(maze_stats$quad),]
temp=maze_stats %>% group_by(grid, quad) %>% summarise(sumdVGC= sum(dVGC), sumsVGC= sum(sVGC))

latmazes= data.frame(grid = unique(temp$grid),
  hlat_dVGC =abs((temp$sumdVGC[temp$quad=='U'] - temp$sumdVGC[temp$quad=='L']) / (temp$sumdVGC[temp$quad=='U'] + temp$sumdVGC[temp$quad=='L'])),
  hlat_sVGC= abs((temp$sumsVGC[temp$quad=='U'] - temp$sumsVGC[temp$quad=='L']) / (temp$sumsVGC[temp$quad=='U'] + temp$sumsVGC[temp$quad=='L'])))

# make sure the two model predictions are related!
cor.test(latmazesLR$lat_dVGC, latmazesLR$lat_sVGC)
cor.test(latmazes$hlat_dVGC, latmazes$hlat_sVGC)

cor.test(latmazesLR$lat_sVGC, latmazes$hlat_sVGC)
cor.test(latmazesLR$lat_dVGC, latmazes$hlat_dVGC)

index_mazes=paste(data$grid, data$obstacle)

data$lateralized_values_dVGC=as.numeric(plyr::mapvalues(data$grid, dictionary_of_maze, latmazesLR$lat_dVGC))
data$lateralized_values_sVGC=as.numeric(plyr::mapvalues(data$grid, dictionary_of_maze, latmazesLR$lat_sVGC))

data$hor_values_dVGC=as.numeric(plyr::mapvalues(data$grid, dictionary_of_maze, latmazes$hlat_dVGC))
data$hor_values_sVGC=as.numeric(plyr::mapvalues(data$grid, dictionary_of_maze, latmazes$hlat_sVGC))


data$lat_dVGC_scaled= scale(data$lateralized_values_dVGC)[,1]
data$lat_sVGC_scaled= scale(data$lateralized_values_sVGC)[,1]

data$hor_dVGC_scaled= scale(data$hor_values_dVGC)[,1]
data$hor_sVGC_scaled= scale(data$hor_values_sVGC)[,1]

# need to add subject intercept!!
lm0= lmer(attention_N ~  (1 | grid)+ (1 | sessionId), data= data)
lm1= lmer(attention_N ~  (1 | grid) + (1 | sessionId)+ static_vgc_weight_Z, data= data)
lm2= lmer(attention_N ~  (1 | grid) + (1 | sessionId)+ static_vgc_weight_Z + lat_sVGC_scaled, data= data)
lm3= lmer(attention_N ~  (1 | grid) + (1 | sessionId)+ static_vgc_weight_Z * lat_sVGC_scaled, data= data)
anova(lm0,lm1, lm2, lm3)

sjPlot::tab_model(lm3)


lm0= lmer(attention_N ~  (1 | grid)+ (1 | sessionId), data= data)
lm1= lmer(attention_N ~  (1 | grid) + (1 | sessionId)+ static_vgc_weight_Z, data= data)
lm2= lmer(attention_N ~  (1 | grid) + (1 | sessionId)+ static_vgc_weight_Z + hor_sVGC_scaled, data= data)
lm3= lmer(attention_N ~  (1 | grid) + (1 | sessionId)+ static_vgc_weight_Z * hor_sVGC_scaled, data= data)
anova(lm0,lm1, lm2, lm3)

sjPlot::tab_model(lm3)

# need to add subject intercept!!
lm0= lmer(attention_N ~  (1 | grid) + (1 | sessionId), data= data)
lm1= lmer(attention_N ~  (1 | grid) + (1 | sessionId)+ dynamic_vgc_weight_Z, data= data)
lm2= lmer(attention_N ~  (1 | grid) + (1 | sessionId)+ dynamic_vgc_weight_Z + lat_dVGC_scaled, data= data)
lm3= lmer(attention_N ~  (1 | grid) + (1 | sessionId)+ dynamic_vgc_weight_Z * lat_dVGC_scaled, data= data)
anova(lm0,lm1, lm2, lm3)

sjPlot::tab_model(lm3)
# non-significant! 


lm0= lmer(attention_N ~  (1 | grid) + (1 | sessionId), data= data)
lm1= lmer(attention_N ~  (1 | grid) + (1 | sessionId)+ dynamic_vgc_weight_Z, data= data)
lm2= lmer(attention_N ~  (1 | grid) + (1 | sessionId)+ dynamic_vgc_weight_Z + hor_dVGC_scaled, data= data)
lm3= lmer(attention_N ~  (1 | grid) + (1 | sessionId)+ dynamic_vgc_weight_Z * hor_dVGC_scaled, data= data)
anova(lm0,lm1, lm2, lm3)

sjPlot::tab_model(lm3)


# add in nuissance covariates 
# need to add subject intercept!!
lm0= lmer(attention_N ~  start_dist_Z+ goal_dist_Z + walls_dist_Z + center_dist + (1 | grid) + (1 | sessionId), data= data)
lm1= lmer(attention_N ~ start_dist_Z+ goal_dist_Z + walls_dist_Z + center_dist + (1 | grid) + (1 | sessionId) + static_vgc_weight_Z, data= data)
lm2= lmer(attention_N ~  start_dist_Z+ goal_dist_Z + walls_dist_Z + center_dist +(1 | grid) + (1 | sessionId) + static_vgc_weight_Z + lat_sVGC_scaled, data= data)
lm3= lmer(attention_N ~  start_dist_Z+ goal_dist_Z + walls_dist_Z + center_dist +(1 | grid) + (1 | sessionId) + static_vgc_weight_Z * lat_sVGC_scaled, data= data)
anova(lm0,lm1, lm2, lm3)

sjPlot::tab_model(lm3)
# we see a smaller (but still significant effect!)



# plot sVGC effect 
data_plot= data

# summarize by maze 
data_plot= data %>% group_by(grid, obstacle) %>% summarise(mean_awareness= mean(attention), mean_sVGC= mean(static_vgc_weight), mean_dVGC= mean(dynamic_vgc_weight),lat_sVGC= mean(lateralized_values_sVGC), lat_dVGC= mean(lateralized_values_dVGC),hor_sVGC= mean(hor_values_sVGC), hor_dVGC= mean(hor_values_dVGC) )

# remove intercept of each maze 
temp=data_plot %>% group_by(grid) %>% summarise(mean_awareness= mean(mean_awareness), mean_sVGC= mean(mean_sVGC), mean_dVGC= mean(mean_dVGC))

data_plot$mean_awareness= data_plot$mean_awareness-  rep(temp$mean_awareness, each=7)
data_plot$mean_sVGC= data_plot$mean_sVGC-  rep(temp$mean_sVGC, each=7)
data_plot$mean_dVGC= data_plot$mean_dVGC-  rep(temp$mean_dVGC, each=7)

ggplot(data_plot, aes(x=mean_sVGC, y= mean_awareness, color=lat_sVGC, fill= lat_sVGC, group = factor(lat_sVGC)))+  geom_point() + theme_classic() + xlab("") +  ylab("awareness reports (scaled)") + xlab('sVGC (scaled)')  + theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14)) + geom_smooth(aes( color=lat_sVGC, fill= lat_sVGC), method='lm', se= FALSE, fullrange = T) +  colorspace::scale_color_continuous_sequential(palette = 'Orange', limits = c(0,1)) + colorspace::scale_fill_continuous_sequential(palette = 'Orange',limits = c(0,1)) 

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/datapilot/ORIGINAL_experiment2_interaction_plot_continuous_lateralized_sVGC.pdf', device = "pdf", width= 6, height =5)

ggplot(data_plot, aes(x=mean_dVGC, y= mean_awareness, color=lat_dVGC, fill= lat_dVGC, group = factor(lat_dVGC)))+  geom_point() + theme_classic() + xlab("") +  ylab("awareness reports (scaled)") + xlab('dVGC (scaled)')  + theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14)) + geom_smooth(aes( color=lat_sVGC, fill= lat_sVGC), method='lm', se= FALSE, fullrange = T) +  colorspace::scale_color_continuous_sequential(palette = 'Orange', limits = c(0,1)) + colorspace::scale_fill_continuous_sequential(palette = 'Orange',limits = c(0,1)) 

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/datapilot/ORIGINAL_experiment2_interaction_plot_continuous_lateralized_dVGC.pdf', device = "pdf", width= 6, height =5)


ggplot(data_plot, aes(x=mean_sVGC, y= mean_awareness, color=hor_sVGC, fill= hor_sVGC, group = factor(hor_sVGC)))+  geom_point() + theme_classic() + xlab("") +  ylab("awareness reports (scaled)") + xlab('sVGC (scaled)')  + theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14)) + geom_smooth(aes( color=lat_sVGC, fill= lat_sVGC), method='lm', se= FALSE, fullrange = T) +  colorspace::scale_color_continuous_sequential(palette = 'Orange', limits = c(0,1)) + colorspace::scale_fill_continuous_sequential(palette = 'Orange',limits = c(0,1)) 

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/datapilot/ORIGINAL_experiment2_interaction_plot_continuous_lateralized_horizontal_sVGC.pdf', device = "pdf", width= 6, height =5)

ggplot(data_plot, aes(x=mean_dVGC, y= mean_awareness, color=hor_dVGC, fill= hor_dVGC, group = factor(hor_dVGC)))+  geom_point() + theme_classic() + xlab("") +  ylab("awareness reports (scaled)") + xlab('dVGC (scaled)')  + theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14)) + geom_smooth(aes( color=lat_sVGC, fill= lat_sVGC), method='lm', se= FALSE, fullrange = T) +  colorspace::scale_color_continuous_sequential(palette = 'Orange', limits = c(0,1)) + colorspace::scale_fill_continuous_sequential(palette = 'Orange',limits = c(0,1)) 

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/datapilot/ORIGINAL_experiment2_interaction_plot_continuous_lateralized_horizontal_dVGC.pdf', device = "pdf", width= 6, height =5)


data$Lateralized.factor = data$lateralized_values_sVGC >=0.40
data$Lateralized.factor= factor(plyr::mapvalues(data$Lateralized.factor, c(1,0), c('lateralized', 'non-lateralized')), levels = c('non-lateralized', 'lateralized'))
data$binarysVGC= data$static_vgc_weight > 0.5
data$binarysVGC= plyr::mapvalues(data$binarysVGC, c(1,0), c('relevant', 'irrelevant'))

ggplot(data, aes(attention_N, group= binarysVGC, color= binarysVGC, fill=binarysVGC, alpha=0.5)) +
  geom_density(aes( color= binarysVGC, fill=binarysVGC, group= binarysVGC), alpha= 0.5, bins = 9, position = 'identity') +
  theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14), legend.position = 'none') +
  labs(x = "awareness of obstacle", y = "count")  + ggpubr::theme_classic2() +
  ggtitle("") + scale_fill_manual(values=c('#B9E615', '#F36A17')) + scale_color_manual(values=c('#B9E615', '#F36A17')) + facet_wrap(~Lateralized.factor, nrow = 1)

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/datapilot/ORIG_EXP_2_hist_of_awareness_by_maze_type2.pdf', device = "pdf", width= 10, height =5)


```



```{r check lateralization of original experiment 3}

#expriment with awareness probes, but obstacles disapear after participants starts to move

library(dplyr)
library(ggplot2)

data = read.csv('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/experiment_3_data.csv')


temp=data %>% group_by(grid,obstacle) %>% summarise(goal_dist= mean(goal_dist), start_dist= mean(start_dist), wall_dist= mean(walls_dist), center_dist= mean(center_dist), dVGC= mean(dynamic_vgc_weight), sVGC= mean(static_vgc_weight))

maze_stats= read.csv('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/original_stimuli_stats.csv', na.strings = 'NaN')

maze_stats=maze_stats[order(maze_stats$grid),]

dictionary_of_maze=unique(unlist(strsplit(maze_stats$grid, '-0')))[2:17]
dictionary_of_maze[1] = 'grid-0'

maze_stats=maze_stats[!is.na(maze_stats$side),]
temp=maze_stats %>% group_by(grid, side) %>% summarise(sumdVGC= sum(dVGC), sumsVGC= sum(sVGC))

latmazesLR= data.frame(grid = unique(temp$grid),
  lat_dVGC =abs((temp$sumdVGC[temp$side=='R'] - temp$sumdVGC[temp$side=='L']) / (temp$sumdVGC[temp$side=='R'] + temp$sumdVGC[temp$side=='L'])),
  lat_sVGC= abs((temp$sumsVGC[temp$side=='R'] - temp$sumsVGC[temp$side=='L']) / (temp$sumsVGC[temp$side=='R'] + temp$sumsVGC[temp$side=='L'])))


maze_stats=maze_stats[!is.na(maze_stats$quad),]
temp=maze_stats %>% group_by(grid, quad) %>% summarise(sumdVGC= sum(dVGC), sumsVGC= sum(sVGC))

latmazes= data.frame(grid = unique(temp$grid),
  hlat_dVGC =abs((temp$sumdVGC[temp$quad=='U'] - temp$sumdVGC[temp$quad=='L']) / (temp$sumdVGC[temp$quad=='U'] + temp$sumdVGC[temp$quad=='L'])),
  hlat_sVGC= abs((temp$sumsVGC[temp$quad=='U'] - temp$sumsVGC[temp$quad=='L']) / (temp$sumsVGC[temp$quad=='U'] + temp$sumsVGC[temp$quad=='L'])))

# make sure the two model predictions are related!
cor.test(latmazesLR$lat_dVGC, latmazesLR$lat_sVGC)
cor.test(latmazes$hlat_dVGC, latmazes$hlat_sVGC)

cor.test(latmazesLR$lat_sVGC, latmazes$hlat_sVGC)
cor.test(latmazesLR$lat_dVGC, latmazes$hlat_dVGC)



index_mazes=paste(data$grid, data$obstacle)

data$lateralized_values_dVGC=as.numeric(plyr::mapvalues(data$grid, dictionary_of_maze, latmazesLR$lat_dVGC))
data$lateralized_values_sVGC=as.numeric(plyr::mapvalues(data$grid, dictionary_of_maze, latmazesLR$lat_sVGC))

data$hor_values_dVGC=as.numeric(plyr::mapvalues(data$grid, dictionary_of_maze, latmazes$hlat_dVGC))
data$hor_values_sVGC=as.numeric(plyr::mapvalues(data$grid, dictionary_of_maze, latmazes$hlat_sVGC))


data$lat_dVGC_scaled= scale(data$lateralized_values_dVGC)[,1]
data$lat_sVGC_scaled= scale(data$lateralized_values_sVGC)[,1]

data$hor_dVGC_scaled= scale(data$hor_values_dVGC)[,1]
data$hor_sVGC_scaled= scale(data$hor_values_sVGC)[,1]


```



# cant fit experiment 3 bc critical mazes have no variance asscoitaed with lateralization (3 levels for dVGC and 2 sVGC)

# let us skip straight to exp 4 which uses all mazes 



```{r check lateralization of original experiment 4}

#expriment with awareness probes, but obstacles disapear after participants starts to move

library(dplyr)
library(ggplot2)

data = read.csv('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/experiment_4a_ht_data.csv')

temp=data %>% group_by(grid,obstacle) %>% summarise(goal_dist= mean(goal_dist), start_dist= mean(start_dist), wall_dist= mean(walls_dist), center_dist= mean(center_dist), dVGC= mean(dynamic_vgc_weight), sVGC= mean(static_vgc_weight))

maze_stats= read.csv('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/original_stimuli_stats.csv', na.strings = 'NaN')

maze_stats=maze_stats[order(maze_stats$grid),]

dictionary_of_maze=unique(unlist(strsplit(maze_stats$grid, '-0')))[2:17]
dictionary_of_maze[1] = 'grid-0'

maze_stats=maze_stats[!is.na(maze_stats$side),]
temp=maze_stats %>% group_by(grid, side) %>% summarise(sumdVGC= sum(dVGC), sumsVGC= sum(sVGC))

latmazesLR= data.frame(grid = unique(temp$grid),
  lat_dVGC =abs((temp$sumdVGC[temp$side=='R'] - temp$sumdVGC[temp$side=='L']) / (temp$sumdVGC[temp$side=='R'] + temp$sumdVGC[temp$side=='L'])),
  lat_sVGC= abs((temp$sumsVGC[temp$side=='R'] - temp$sumsVGC[temp$side=='L']) / (temp$sumsVGC[temp$side=='R'] + temp$sumsVGC[temp$side=='L'])))


maze_stats=maze_stats[!is.na(maze_stats$quad),]
temp=maze_stats %>% group_by(grid, quad) %>% summarise(sumdVGC= sum(dVGC), sumsVGC= sum(sVGC))

latmazes= data.frame(grid = unique(temp$grid),
  hlat_dVGC =abs((temp$sumdVGC[temp$quad=='U'] - temp$sumdVGC[temp$quad=='L']) / (temp$sumdVGC[temp$quad=='U'] + temp$sumdVGC[temp$quad=='L'])),
  hlat_sVGC= abs((temp$sumsVGC[temp$quad=='U'] - temp$sumsVGC[temp$quad=='L']) / (temp$sumsVGC[temp$quad=='U'] + temp$sumsVGC[temp$quad=='L'])))

# make sure the two model predictions are related!
cor.test(latmazesLR$lat_dVGC, latmazesLR$lat_sVGC)
cor.test(latmazes$hlat_dVGC, latmazes$hlat_sVGC)

cor.test(latmazesLR$lat_sVGC, latmazes$hlat_sVGC)
cor.test(latmazesLR$lat_dVGC, latmazes$hlat_dVGC)

index_mazes=paste(data$grid, data$obstacle)

data$lateralized_values_dVGC=as.numeric(plyr::mapvalues(data$grid, dictionary_of_maze, latmazesLR$lat_dVGC))
data$lateralized_values_sVGC=as.numeric(plyr::mapvalues(data$grid, dictionary_of_maze, latmazesLR$lat_sVGC))

data$hor_values_dVGC=as.numeric(plyr::mapvalues(data$grid, dictionary_of_maze, latmazes$hlat_dVGC))
data$hor_values_sVGC=as.numeric(plyr::mapvalues(data$grid, dictionary_of_maze, latmazes$hlat_sVGC))


data$lat_dVGC_scaled= scale(data$lateralized_values_dVGC)[,1]
data$lat_sVGC_scaled= scale(data$lateralized_values_sVGC)[,1]

data$hor_dVGC_scaled= scale(data$hor_values_dVGC)[,1]
data$hor_sVGC_scaled= scale(data$hor_values_sVGC)[,1]

# need to add subject intercept!!
lm0= lmer(log_hoverduration ~  (1 | grid)+ (1 | sessionId), data= data)
lm1= lmer(log_hoverduration ~  (1 | grid) + (1 | sessionId)+ static_vgc_weight_Z, data= data)
lm2= lmer(log_hoverduration ~  (1 | grid) + (1 | sessionId)+ static_vgc_weight_Z + lat_sVGC_scaled, data= data)
lm3= lmer(log_hoverduration ~  (1 | grid) + (1 | sessionId)+ static_vgc_weight_Z * lat_sVGC_scaled, data= data)
anova(lm0,lm1, lm2, lm3)

sjPlot::tab_model(lm3)
# we see a smaller (but still significant effect!)


# need to add subject intercept!!
lm0= lmer(log_hoverduration ~  (1 | grid)+ (1 | sessionId), data= data)
lm1= lmer(log_hoverduration ~  (1 | grid) + (1 | sessionId)+ static_vgc_weight_Z, data= data)
lm2= lmer(log_hoverduration ~  (1 | grid) + (1 | sessionId)+ static_vgc_weight_Z + hor_sVGC_scaled, data= data)
lm3= lmer(log_hoverduration ~  (1 | grid) + (1 | sessionId)+ static_vgc_weight_Z * hor_sVGC_scaled, data= data)
anova(lm0,lm1, lm2, lm3)

sjPlot::tab_model(lm3)

# need to add subject intercept!!
lm0= lmer(log_hoverduration ~  (1 | grid) + (1 | sessionId), data= data)
lm1= lmer(log_hoverduration ~  (1 | grid) + (1 | sessionId)+ dynamic_vgc_weight_Z, data= data)
lm2= lmer(log_hoverduration ~  (1 | grid) + (1 | sessionId)+ dynamic_vgc_weight_Z + lat_dVGC_scaled, data= data)
lm3= lmer(log_hoverduration ~  (1 | grid) + (1 | sessionId)+ dynamic_vgc_weight_Z * lat_dVGC_scaled, data= data)
anova(lm0,lm1, lm2, lm3)

sjPlot::tab_model(lm3)
# we see a smaller (but still significant effect!)

# need to add subject intercept!!
lm0= lmer(log_hoverduration ~  (1 | grid) + (1 | sessionId), data= data)
lm1= lmer(log_hoverduration ~  (1 | grid) + (1 | sessionId)+ dynamic_vgc_weight_Z, data= data)
lm2= lmer(log_hoverduration ~  (1 | grid) + (1 | sessionId)+ dynamic_vgc_weight_Z + hor_dVGC_scaled, data= data)
lm3= lmer(log_hoverduration ~  (1 | grid) + (1 | sessionId)+ dynamic_vgc_weight_Z * hor_dVGC_scaled, data= data)
anova(lm0,lm1, lm2, lm3)

sjPlot::tab_model(lm3)



# add in nuissance covariates 
# need to add subject intercept!!
lm0= lmer(log_hoverduration ~  start_dist_Z+ goal_dist_Z + walls_dist_Z + center_dist + (1 | grid) + (1 | sessionId), data= data)
lm1= lmer(log_hoverduration ~ start_dist_Z+ goal_dist_Z + walls_dist_Z + center_dist + (1 | grid) + (1 | sessionId) + static_vgc_weight_Z, data= data)
lm2= lmer(log_hoverduration ~  start_dist_Z+ goal_dist_Z + walls_dist_Z + center_dist +(1 | grid) + (1 | sessionId) + static_vgc_weight_Z + lat_sVGC_scaled, data= data)
lm3= lmer(log_hoverduration ~  start_dist_Z+ goal_dist_Z + walls_dist_Z + center_dist +(1 | grid) + (1 | sessionId) + static_vgc_weight_Z * lat_sVGC_scaled, data= data)
anova(lm0,lm1, lm2, lm3)

sjPlot::tab_model(lm3)
# we see a smaller (but still significant effect!)


lm0= lmer(log_hoverduration ~  start_dist_Z+ goal_dist_Z + walls_dist_Z + center_dist + (1 | grid) + (1 | sessionId), data= data)
lm1= lmer(log_hoverduration ~ start_dist_Z+ goal_dist_Z + walls_dist_Z + center_dist + (1 | grid) + (1 | sessionId) + dynamic_vgc_weight_Z, data= data)
lm2= lmer(log_hoverduration ~  start_dist_Z+ goal_dist_Z + walls_dist_Z + center_dist +(1 | grid) + (1 | sessionId) + dynamic_vgc_weight_Z + lat_dVGC_scaled, data= data)
lm3= lmer(log_hoverduration ~  start_dist_Z+ goal_dist_Z + walls_dist_Z + center_dist +(1 | grid) + (1 | sessionId) + dynamic_vgc_weight_Z * lat_dVGC_scaled, data= data)
anova(lm0,lm1, lm2, lm3)

sjPlot::tab_model(lm3)
# no effect now but trending! 



# plot sVGC effect 
data_plot= data

# summarize by maze 
data_plot= data %>% group_by(grid, obstacle) %>% summarise(mean_hovdur= mean(log_hoverduration, na.rm= TRUE), mean_sVGC= mean(static_vgc_weight), mean_dVGC= mean(dynamic_vgc_weight),lat_sVGC= mean(lateralized_values_sVGC), lat_dVGC= mean(lateralized_values_dVGC), hor_sVGC= mean(hor_values_sVGC), hor_dVGC= mean(hor_values_dVGC) )


# remove intercept of each maze 
temp=data_plot %>% group_by(grid) %>% summarise(mean_hovdur= mean(mean_hovdur, na.rm= TRUE), mean_sVGC= mean(mean_sVGC), mean_dVGC= mean(mean_dVGC))

data_plot$mean_hovdur= data_plot$mean_hovdur-  rep(temp$mean_hovdur, each=7)
data_plot$mean_sVGC= data_plot$mean_sVGC-  rep(temp$mean_sVGC, each=7)
data_plot$mean_dVGC= data_plot$mean_dVGC-  rep(temp$mean_dVGC, each=7)

ggplot(data_plot, aes(x=mean_sVGC, y= mean_hovdur, color=lat_sVGC, fill= lat_sVGC, group = factor(lat_sVGC)))+  geom_point() + theme_classic() + xlab("") +  ylab("log hover duration") + xlab('sVGC (scaled)')  + theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14)) + geom_smooth(aes( color=lat_sVGC, fill= lat_sVGC), method='lm', se= FALSE, fullrange = T) +  colorspace::scale_color_continuous_sequential(palette = 'Orange', limits = c(0,1)) + colorspace::scale_fill_continuous_sequential(palette = 'Orange',limits = c(0,1)) 

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/datapilot/ORIGINAL_experiment4_interaction_plot_continuous_lateralized_sVGC_hoverduration.pdf', device = "pdf", width= 6, height =5)

ggplot(data_plot, aes(x=mean_dVGC, y= mean_hovdur, color=lat_dVGC, fill= lat_dVGC, group = factor(lat_dVGC)))+  geom_point() + theme_classic() + xlab("") +  ylab("log hover duration") + xlab('dVGC (scaled)')  + theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14)) + geom_smooth(aes( color=lat_sVGC, fill= lat_sVGC), method='lm', se= FALSE, fullrange = T) +  colorspace::scale_color_continuous_sequential(palette = 'Orange', limits = c(0,1)) + colorspace::scale_fill_continuous_sequential(palette = 'Orange',limits = c(0,1)) 

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/datapilot/ORIGINAL_experiment4_interaction_plot_continuous_lateralized_dVGC_hoverduration.pdf', device = "pdf", width= 6, height =5)


ggplot(data_plot, aes(x=mean_sVGC, y= mean_hovdur, color=hor_sVGC, fill= hor_sVGC, group = factor(hor_sVGC)))+  geom_point() + theme_classic() + xlab("") +  ylab("log hover duration") + xlab('sVGC (scaled)')  + theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14)) + geom_smooth(aes( color=lat_sVGC, fill= lat_sVGC), method='lm', se= FALSE, fullrange = T) +  colorspace::scale_color_continuous_sequential(palette = 'Orange', limits = c(0,1)) + colorspace::scale_fill_continuous_sequential(palette = 'Orange',limits = c(0,1)) 

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/datapilot/ORIGINAL_experiment4_interaction_plot_continuous_lateralized_horizontal_sVGC_hoverduration.pdf', device = "pdf", width= 6, height =5)

ggplot(data_plot, aes(x=mean_dVGC, y= mean_hovdur, color=hor_dVGC, fill= hor_dVGC, group = factor(hor_dVGC)))+  geom_point() + theme_classic() + xlab("") +  ylab("log hover duration") + xlab('dVGC (scaled)')  + theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14)) + geom_smooth(aes( color=lat_sVGC, fill= lat_sVGC), method='lm', se= FALSE, fullrange = T) +  colorspace::scale_color_continuous_sequential(palette = 'Orange', limits = c(0,1)) + colorspace::scale_fill_continuous_sequential(palette = 'Orange',limits = c(0,1)) 

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/datapilot/ORIGINAL_experiment2_interaction_plot_continuous_lateralized_horizontal_dVGC_hoverduration.pdf', device = "pdf", width= 6, height =5)



# adjust for multiple corrections 
p.adjust(c(7.786e-05, 0.001, 0.001, 0.473, 0.031, 0.234, 0.008, 0.006), method = 'fdr')

p.adjust(c(0.478, 0.013, 0.008, 0.049, 0.797, 0.191, 0.001, 0.094), method = 'fdr')

```


```{r experiment 4 binary hovered}

# glmer test

data$hoveredBin= as.numeric(plyr::mapvalues(data$hovered, c("True", "False"), c(1, 0)))

lm0= glmer(hoveredBin ~   (1 | grid) + (1 | sessionId), data= data, family = 'binomial')
lm1= glmer(hoveredBin ~  (1 | grid) + (1 | sessionId) + static_vgc_weight_Z, data= data, family = 'binomial')
lm2= glmer(hoveredBin ~  (1 | grid) + (1 | sessionId) + static_vgc_weight_Z + lat_sVGC_scaled, data= data, family = 'binomial')
lm3= glmer(hoveredBin ~  (1 | grid) + (1 | sessionId) + static_vgc_weight_Z * lat_sVGC_scaled, data= data, family = 'binomial')
anova(lm0,lm1, lm2, lm3)

sjPlot::tab_model(lm3)

lm0= glmer(hoveredBin ~   (1 | grid) + (1 | sessionId), data= data, family = 'binomial')
lm1= glmer(hoveredBin ~  (1 | grid) + (1 | sessionId) + static_vgc_weight_Z, data= data, family = 'binomial')
lm2= glmer(hoveredBin ~  (1 | grid) + (1 | sessionId) + static_vgc_weight_Z + hor_sVGC_scaled, data= data, family = 'binomial')
lm3= glmer(hoveredBin ~  (1 | grid) + (1 | sessionId) + static_vgc_weight_Z * hor_sVGC_scaled, data= data, family = 'binomial')
anova(lm0,lm1, lm2, lm3)

sjPlot::tab_model(lm3)



lm0= glmer(hoveredBin ~   (1 | grid) + (1 | sessionId), data= data, family = 'binomial')
lm1= glmer(hoveredBin ~  (1 | grid) + (1 | sessionId) + dynamic_vgc_weight_Z, data= data, family = 'binomial')
lm2= glmer(hoveredBin ~  (1 | grid) + (1 | sessionId) + dynamic_vgc_weight_Z + lat_dVGC_scaled, data= data, family = 'binomial')
lm3= glmer(hoveredBin ~  (1 | grid) + (1 | sessionId) + dynamic_vgc_weight_Z * lat_dVGC_scaled, data= data, family = 'binomial')
anova(lm0,lm1, lm2, lm3)

sjPlot::tab_model(lm3)

lm0= glmer(hoveredBin ~   (1 | grid) + (1 | sessionId), data= data, family = 'binomial')
lm1= glmer(hoveredBin ~  (1 | grid) + (1 | sessionId) + dynamic_vgc_weight_Z, data= data, family = 'binomial')
lm2= glmer(hoveredBin ~  (1 | grid) + (1 | sessionId) + dynamic_vgc_weight_Z + hor_dVGC_scaled, data= data, family = 'binomial')
lm3= glmer(hoveredBin ~  (1 | grid) + (1 | sessionId) + dynamic_vgc_weight_Z * hor_dVGC_scaled, data= data, family = 'binomial')
anova(lm0,lm1, lm2, lm3)

sjPlot::tab_model(lm3)

```



Let us repeat the process of the model fitting with the new averaging technqiue

```{r Calculate averaging for experiment 1}

# function that takes in json inputs and converts to matrix for simple math
json2matrix <- function(mazeA){
  m=t(matrix(unlist(strsplit(mazeA, split='')), nrow = 11))
  return(m)
}

# function to compute manhattan distance between all pairs of obstacles 
obstacle_distances <- function(mazeA){
  number_obs= length(unique(as.numeric(mazeA)))-1
  max_obs= max(as.numeric(mazeA), na.rm = TRUE)
  min_obs= min(as.numeric(mazeA), na.rm = TRUE)
  mazeA[mazeA=='G']=NaN
  mazeA[mazeA=='S']=NaN
  mazeA[mazeA=='.']=NaN
  mazeA[mazeA=='#']=NaN

  obstacle_distances_output= matrix(, nrow=number_obs*number_obs, 3)
  obstacle_distances_output[,1] = rep(seq(min_obs,max_obs), each=7)
  obstacle_distances_output[,2] = rep(seq(min_obs,max_obs), 7)
  
  output=c()
  for (i in min_obs:max_obs){
    for (j in min_obs:max_obs){
      obs1=which(mazeA== as.character(i))
      obs1x= obs1 %% 11
      obs1x[obs1x==0] =11
      obs1y= ceiling(obs1/11)
      obs2= which(mazeA== as.character(j))
      obs2x= obs2 %% 11
      obs2x[obs2x==0] =11
      obs2y= ceiling(obs2/11)
      
      distance =c()
      for (obsA in 1:length(obs1x)){
        for (obsB in 1:length(obs2x)){
          distance= c(distance, abs(obs1x[obsA]-obs2x) + abs(obs1y[obsB]-obs2y))
        }
      }
    
      output= c(output,min(distance))
    }
  }
  obstacle_distances_output[,3]=output
  return(obstacle_distances_output)
}


library(dplyr)
library(lme4)
library(ggplot2)

data = read.csv('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/experiment_1_data.csv')

temp=data %>% group_by(grid,obstacle) %>% summarise(goal_dist= mean(goal_dist), start_dist= mean(start_dist), wall_dist= mean(walls_dist), center_dist= mean(center_dist), dVGC= mean(dynamic_vgc_weight), sVGC= mean(static_vgc_weight))

maze_stats= read.csv('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/original_stimuli_stats.csv', na.strings = 'NaN')

maze_stats=maze_stats[order(maze_stats$grid),]

json_data <- rjson::fromJSON(file='~/Documents/ValueBasedConstrualTask/value-guided-construal-main/experiments/mazes/mazes_0-11.json')

matrix_mazes=lapply(json_data, json2matrix)

maze_stats_new= maze_stats

k_min=3
for (i in 1:length(json_data)){

    grid_name_temp= names(matrix_mazes)[i]
    temp= obstacle_distances(matrix_mazes[[i]])
    sVGC = maze_stats_new$sVGC[maze_stats_new$grid == grid_name_temp]
    sVGC_new = maze_stats_new$sVGC[maze_stats_new$grid == grid_name_temp]
    
    dVGC = maze_stats_new$dVGC[maze_stats_new$grid == grid_name_temp]
    dVGC_new = maze_stats_new$dVGC[maze_stats_new$grid == grid_name_temp]
    
    count=1
    for(j in unique(temp[,1])){
      obs_temp=temp[temp[,1]==j,]
      index= obs_temp[,3] <= k_min
      sVGC_new[count] = mean(sVGC[index])
      dVGC_new[count] = mean(dVGC[index])
      count= count+1
    }
    maze_stats_new$new_sVGC[maze_stats_new$grid == grid_name_temp]=sVGC_new
    maze_stats_new$new_dVGC[maze_stats_new$grid == grid_name_temp]=dVGC_new
}


index_mazes=paste(data$grid, data$obstacle)
dictionary_of_maze= paste(stringr::str_remove(maze_stats_new$grid, '-0'), maze_stats_new$obstacle)

data$new_dVGC=as.numeric(plyr::mapvalues(index_mazes, dictionary_of_maze, maze_stats_new$new_sVGC))
data$new_sVGC=as.numeric(plyr::mapvalues(index_mazes, dictionary_of_maze, maze_stats_new$new_sVGC))

data$new_sVGC.zscored= scale(data$new_sVGC)[,1]
data$new_dVGC.zscored= scale(data$new_dVGC)[,1]

lm0= lmer(attention_N ~  (1 | grid)+ (1 | sessionId), data= data)
lm1= lmer(attention_N ~  (1 | grid) + (1 | sessionId)+ static_vgc_weight_Z, data= data)
lm2= lmer(attention_N ~  (1 | grid) + (1 | sessionId)+ new_sVGC.zscored, data= data)
anova(lm0,lm1, lm2)
BIC(lm2)-BIC(lm1)

# plot sVGC effect 
data_plot= data

# summarize by maze 
data_plot= data %>% group_by(grid, obstacle) %>% summarise(mean_awareness= mean(attention_N), mean_sVGC= mean(static_vgc_weight), mean_dVGC= mean(dynamic_vgc_weight),new_sVGC= mean(new_sVGC), new_dVGC= mean(new_dVGC) )


ggplot(data_plot, aes(x=mean_sVGC, y= mean_awareness))+  geom_point(color= '#B9E615', size=4) + theme_classic() + xlab("") +  ylab("awareness reports (scaled)") + xlab('sVGC (scaled)')  + theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14)) + geom_smooth(aes(), method='lm', se= TRUE, fullrange = T, color= '#B9E615', fill= '#B9E615', size=1.25) + geom_point(aes(x=new_sVGC, y= mean_awareness), color= '#F36A17', size=4) + geom_smooth(aes(x=new_sVGC, y= mean_awareness), method='lm', se= TRUE, fullrange = T, color= '#F36A17', fill= '#F36A17', size=1.25)

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/datapilot/ORIGINAL_experiment1_new_averaging_model_sVGC_k_3.pdf', device = "pdf", width= 6, height =5)

# replot the histograms of the original and new predictions 


dataplot= data %>% group_by(grid, obstacle) %>% summarise(attention_N= mean(attention_N), new_sVGC= mean(static_vgc_weight))

dataplot$binarysVGC= dataplot$new_sVGC > 0.5
dataplot$binarysVGC= plyr::mapvalues(dataplot$binarysVGC, c(1,0), c('relevant', 'irrelevant'))

dataplot2= data %>% group_by(grid, obstacle) %>% summarise(attention_N= mean(attention_N), new_sVGC= mean(new_sVGC))

dataplot2$binarysVGC= dataplot2$new_sVGC > 0.5
dataplot2$binarysVGC= plyr::mapvalues(dataplot2$binarysVGC, c(1,0), c('relevant', 'irrelevant'))

dataplot=rbind(dataplot,dataplot2)
dataplot$model = rep(c('original', 'attentional'), each=84)

ggplot(dataplot, aes(attention_N, group= binarysVGC, color= binarysVGC, fill=binarysVGC, alpha=0.5)) +
  geom_histogram(aes( color= binarysVGC, fill=binarysVGC, group= binarysVGC), alpha= 0.5, bins = 9, position = 'identity') +
  theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14), legend.position = 'none') +
  labs(x = "awareness of obstacle", y = "count")  + ggpubr::theme_classic2() +
  ggtitle("") + scale_fill_manual(values=c('#B9E615', '#F36A17')) + scale_color_manual(values=c('#B9E615', '#F36A17')) + facet_wrap(~model)

```





```{r Calculate averaging for experiment 2}

# function that takes in json inputs and converts to matrix for simple math
json2matrix <- function(mazeA){
  m=t(matrix(unlist(strsplit(mazeA, split='')), nrow = 11))
  return(m)
}

# function to compute manhattan distance between all pairs of obstacles 
obstacle_distances <- function(mazeA){
  number_obs= length(unique(as.numeric(mazeA)))-1
  max_obs= max(as.numeric(mazeA), na.rm = TRUE)
  min_obs= min(as.numeric(mazeA), na.rm = TRUE)
  mazeA[mazeA=='G']=NaN
  mazeA[mazeA=='S']=NaN
  mazeA[mazeA=='.']=NaN
  mazeA[mazeA=='#']=NaN

  obstacle_distances_output= matrix(, nrow=number_obs*number_obs, 3)
  obstacle_distances_output[,1] = rep(seq(min_obs,max_obs), each=7)
  obstacle_distances_output[,2] = rep(seq(min_obs,max_obs), 7)
  
  output=c()
  for (i in min_obs:max_obs){
    for (j in min_obs:max_obs){
      obs1=which(mazeA== as.character(i))
      obs1x= obs1 %% 11
      obs1x[obs1x==0] =11
      obs1y= ceiling(obs1/11)
      obs2= which(mazeA== as.character(j))
      obs2x= obs2 %% 11
      obs2x[obs2x==0] =11
      obs2y= ceiling(obs2/11)
      
      distance =c()
      for (obsA in 1:length(obs1x)){
        for (obsB in 1:length(obs2x)){
          distance= c(distance, abs(obs1x[obsA]-obs2x) + abs(obs1y[obsB]-obs2y))
        }
      }
    
      output= c(output,min(distance))
    }
  }
  obstacle_distances_output[,3]=output
  return(obstacle_distances_output)
}


library(dplyr)
library(lme4)
library(ggplot2)

data = read.csv('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/experiment_2_data.csv')

temp=data %>% group_by(grid,obstacle) %>% summarise(goal_dist= mean(goal_dist), start_dist= mean(start_dist), wall_dist= mean(walls_dist), center_dist= mean(center_dist), dVGC= mean(dynamic_vgc_weight), sVGC= mean(static_vgc_weight))

maze_stats= read.csv('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/original_stimuli_stats.csv', na.strings = 'NaN')

maze_stats=maze_stats[order(maze_stats$grid),]

json_data <- rjson::fromJSON(file='~/Documents/ValueBasedConstrualTask/value-guided-construal-main/experiments/mazes/mazes_0-11.json')

matrix_mazes=lapply(json_data, json2matrix)

maze_stats_new= maze_stats

k_min=3
for (i in 1:length(json_data)){

    grid_name_temp= names(matrix_mazes)[i]
    temp= obstacle_distances(matrix_mazes[[i]])
    sVGC = maze_stats_new$sVGC[maze_stats_new$grid == grid_name_temp]
    sVGC_new = maze_stats_new$sVGC[maze_stats_new$grid == grid_name_temp]
    
    dVGC = maze_stats_new$dVGC[maze_stats_new$grid == grid_name_temp]
    dVGC_new = maze_stats_new$dVGC[maze_stats_new$grid == grid_name_temp]
    
    count=1
    for(j in unique(temp[,1])){
      obs_temp=temp[temp[,1]==j,]
      index= obs_temp[,3] <= k_min
      sVGC_new[count] = mean(sVGC[index])
      dVGC_new[count] = mean(dVGC[index])
      count= count+1
    }
    maze_stats_new$new_sVGC[maze_stats_new$grid == grid_name_temp]=sVGC_new
    maze_stats_new$new_dVGC[maze_stats_new$grid == grid_name_temp]=dVGC_new
}


index_mazes=paste(data$grid, data$obstacle)
dictionary_of_maze= paste(stringr::str_remove(maze_stats_new$grid, '-0'), maze_stats_new$obstacle)

data$new_dVGC=as.numeric(plyr::mapvalues(index_mazes, dictionary_of_maze, maze_stats_new$new_sVGC))
data$new_sVGC=as.numeric(plyr::mapvalues(index_mazes, dictionary_of_maze, maze_stats_new$new_sVGC))

data$new_sVGC.zscored= scale(data$new_sVGC)[,1]
data$new_dVGC.zscored= scale(data$new_dVGC)[,1]

lm0= lmer(attention_N ~  (1 | grid)+ (1 | sessionId), data= data)
lm1= lmer(attention_N ~  (1 | grid) + (1 | sessionId)+ static_vgc_weight_Z, data= data)
lm2= lmer(attention_N ~  (1 | grid) + (1 | sessionId)+ new_sVGC.zscored, data= data)
anova(lm0,lm1, lm2)
BIC(lm2)-BIC(lm1)

# plot sVGC effect 
data_plot= data

# summarize by maze 
data_plot= data %>% group_by(grid, obstacle) %>% summarise(mean_awareness= mean(attention_N), mean_sVGC= mean(static_vgc_weight), mean_dVGC= mean(dynamic_vgc_weight),new_sVGC= mean(new_sVGC), new_dVGC= mean(new_dVGC) )


ggplot(data_plot, aes(x=mean_sVGC, y= mean_awareness))+  geom_point(color= '#B9E615', size=4) + theme_classic() + xlab("") +  ylab("awareness reports (scaled)") + xlab('sVGC (scaled)')  + theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14)) + geom_smooth(aes(), method='lm', se= TRUE, fullrange = T, color= '#B9E615', fill= '#B9E615', size=1.25) + geom_point(aes(x=new_sVGC, y= mean_awareness), color= '#F36A17', size=4) + geom_smooth(aes(x=new_sVGC, y= mean_awareness), method='lm', se= TRUE, fullrange = T, color= '#F36A17', fill= '#F36A17', size=1.25)

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/datapilot/ORIGINAL_experiment2_new_averaging_model_sVGC_k_3.pdf', device = "pdf", width= 6, height =5)

# replot the histograms of the original and new predictions 


dataplot= data %>% group_by(grid, obstacle) %>% summarise(attention_N= mean(attention_N), new_sVGC= mean(static_vgc_weight))

dataplot$binarysVGC= dataplot$new_sVGC > 0.5
dataplot$binarysVGC= plyr::mapvalues(dataplot$binarysVGC, c(1,0), c('relevant', 'irrelevant'))

dataplot2= data %>% group_by(grid, obstacle) %>% summarise(attention_N= mean(attention_N), new_sVGC= mean(new_sVGC))

dataplot2$binarysVGC= dataplot2$new_sVGC > 0.5
dataplot2$binarysVGC= plyr::mapvalues(dataplot2$binarysVGC, c(1,0), c('relevant', 'irrelevant'))

dataplot=rbind(dataplot,dataplot2)
dataplot$model = rep(c('original', 'attentional'), each=84)

ggplot(dataplot, aes(attention_N, group= binarysVGC, color= binarysVGC, fill=binarysVGC, alpha=0.5)) +
  geom_histogram(aes( color= binarysVGC, fill=binarysVGC, group= binarysVGC), alpha= 0.5, bins = 9, position = 'identity') +
  theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14), legend.position = 'none') +
  labs(x = "awareness of obstacle", y = "count")  + ggpubr::theme_classic2() +
  ggtitle("") + scale_fill_manual(values=c('#B9E615', '#F36A17')) + scale_color_manual(values=c('#B9E615', '#F36A17')) + facet_wrap(~model)

```





```{r Calculate averaging for experiment 4}

# function that takes in json inputs and converts to matrix for simple math
json2matrix <- function(mazeA){
  m=t(matrix(unlist(strsplit(mazeA, split='')), nrow = 11))
  return(m)
}

# function to compute manhattan distance between all pairs of obstacles 
obstacle_distances <- function(mazeA){
  number_obs= length(unique(as.numeric(mazeA)))-1
  max_obs= max(as.numeric(mazeA), na.rm = TRUE)
  min_obs= min(as.numeric(mazeA), na.rm = TRUE)
  mazeA[mazeA=='G']=NaN
  mazeA[mazeA=='S']=NaN
  mazeA[mazeA=='.']=NaN
  mazeA[mazeA=='#']=NaN

  obstacle_distances_output= matrix(, nrow=number_obs*number_obs, 3)
  obstacle_distances_output[,1] = rep(seq(min_obs,max_obs), each=7)
  obstacle_distances_output[,2] = rep(seq(min_obs,max_obs), 7)
  
  output=c()
  for (i in min_obs:max_obs){
    for (j in min_obs:max_obs){
      obs1=which(mazeA== as.character(i))
      obs1x= obs1 %% 11
      obs1x[obs1x==0] =11
      obs1y= ceiling(obs1/11)
      obs2= which(mazeA== as.character(j))
      obs2x= obs2 %% 11
      obs2x[obs2x==0] =11
      obs2y= ceiling(obs2/11)
      
      distance =c()
      for (obsA in 1:length(obs1x)){
        for (obsB in 1:length(obs2x)){
          distance= c(distance, abs(obs1x[obsA]-obs2x) + abs(obs1y[obsB]-obs2y))
        }
      }
    
      output= c(output,min(distance))
    }
  }
  obstacle_distances_output[,3]=output
  return(obstacle_distances_output)
}


library(dplyr)
library(lme4)
library(ggplot2)

data = read.csv('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/experiment_4a_ht_data.csv')

temp=data %>% group_by(grid,obstacle) %>% summarise(goal_dist= mean(goal_dist), start_dist= mean(start_dist), wall_dist= mean(walls_dist), center_dist= mean(center_dist), dVGC= mean(dynamic_vgc_weight), sVGC= mean(static_vgc_weight))

maze_stats= read.csv('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/original_stimuli_stats.csv', na.strings = 'NaN')

maze_stats=maze_stats[order(maze_stats$grid),]

json_data <- rjson::fromJSON(file='~/Documents/ValueBasedConstrualTask/value-guided-construal-main/experiments/mazes/mazes_0-11.json')

matrix_mazes=lapply(json_data, json2matrix)

maze_stats_new= maze_stats

k_min=3
for (i in 1:length(json_data)){

    grid_name_temp= names(matrix_mazes)[i]
    temp= obstacle_distances(matrix_mazes[[i]])
    sVGC = maze_stats_new$sVGC[maze_stats_new$grid == grid_name_temp]
    sVGC_new = maze_stats_new$sVGC[maze_stats_new$grid == grid_name_temp]
    
    dVGC = maze_stats_new$dVGC[maze_stats_new$grid == grid_name_temp]
    dVGC_new = maze_stats_new$dVGC[maze_stats_new$grid == grid_name_temp]
    
    count=1
    for(j in unique(temp[,1])){
      obs_temp=temp[temp[,1]==j,]
      index= obs_temp[,3] <= k_min
      sVGC_new[count] = mean(sVGC[index])
      dVGC_new[count] = mean(dVGC[index])
      count= count+1
    }
    maze_stats_new$new_sVGC[maze_stats_new$grid == grid_name_temp]=sVGC_new
    maze_stats_new$new_dVGC[maze_stats_new$grid == grid_name_temp]=dVGC_new
}


index_mazes=paste(data$grid, data$obstacle)
dictionary_of_maze= paste(stringr::str_remove(maze_stats_new$grid, '-0'), maze_stats_new$obstacle)

data$new_dVGC=as.numeric(plyr::mapvalues(index_mazes, dictionary_of_maze, maze_stats_new$new_sVGC))
data$new_sVGC=as.numeric(plyr::mapvalues(index_mazes, dictionary_of_maze, maze_stats_new$new_sVGC))

data$new_sVGC.zscored= scale(data$new_sVGC)[,1]
data$new_dVGC.zscored= scale(data$new_dVGC)[,1]

lm0= lmer(log_hoverduration ~  (1 | grid)+ (1 | sessionId), data= data)
lm1= lmer(log_hoverduration ~  (1 | grid) + (1 | sessionId)+ static_vgc_weight_Z, data= data)
lm2= lmer(log_hoverduration ~  (1 | grid) + (1 | sessionId)+ new_sVGC.zscored, data= data)
anova(lm0,lm1, lm2)
BIC(lm2)-BIC(lm1)


data$hovered=factor(data$hovered)
lm0= glmer(hovered ~  (1 | grid)+ (1 | sessionId), data= data, family = 'binomial')
lm1= glmer(hovered ~  (1 | grid) + (1 | sessionId)+ static_vgc_weight_Z, data= data, family = 'binomial')
lm2= glmer(hovered ~  (1 | grid) + (1 | sessionId)+ new_sVGC.zscored, data= data, family = 'binomial')
anova(lm0,lm1, lm2)
BIC(lm2)-BIC(lm1)


# plot sVGC effect 
data_plot= data

# summarize by maze 
data_plot= data %>% group_by(grid, obstacle) %>% summarise(mean_awareness= mean(log_hoverduration, na.rm= TRUE), mean_sVGC= mean(static_vgc_weight), mean_dVGC= mean(dynamic_vgc_weight),new_sVGC= mean(new_sVGC), new_dVGC= mean(new_dVGC) )


ggplot(data_plot, aes(x=mean_sVGC, y= mean_awareness))+  geom_point(color= '#B9E615', size=4) + theme_classic() + xlab("") +  ylab("awareness reports (scaled)") + xlab('sVGC (scaled)')  + theme(axis.text.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=14)) + geom_smooth(aes(), method='lm', se= TRUE, fullrange = T, color= '#B9E615', fill= '#B9E615', size=1.25) + geom_point(aes(x=new_sVGC, y= mean_awareness), color= '#F36A17', size=4) + geom_smooth(aes(x=new_sVGC, y= mean_awareness), method='lm', se= TRUE, fullrange = T, color= '#F36A17', fill= '#F36A17', size=1.25)

ggsave('~/Documents/ValueBasedConstrualTask/value-guided-construal-main/datapilot/ORIGINAL_experiment4_new_averaging_model_sVGC_k_3.pdf', device = "pdf", width= 6, height =5)

```

